组件名：`ImgMove`

效果描述：容器中，图片尺寸大于容器尺寸；鼠标在容器中移动，图片在容器向相反方向移动；鼠标移动范围为整个容器，图片移动的范围也为整个容器，移动中不会出现页面空白的情况。

效果展示：

页面结构：

1. 一个外层父级容器
   * 宽高撑满100%
   * 父级元素相对定位
   * 开发时可以设置`overflow:visible`,开发完后设为`hidden`。
2. 一个内层图片懒加载组件的包含容器
   * 宽高110%或更大，尺寸超过父容器
   * 绝对定位，且图片居中
   * 开发时可以设置边框，将`z-index`设为-1,便于看清图片在父级容器中的移动。

功能实现：

图片移动

已知鼠标在外层容器中移动，而图片也在外层容器中移动，且图片尺寸大于外层容器。

此时鼠标可移动的范围即为外层容器的面积范围，而图片可移动的范围则为图片面积减去外层容器的面积范围。

当鼠标没有移动时，鼠标距离外层容器左上顶点的相对距离为0，同理，图片距离外层容器左上顶点的距离为0。

当鼠标在可移动范围内横纵距离各移动一半时，图片在可移动范围里的移动距离也应各移动一半，由此可以推断，两者之间存在比例关系。

现在鼠标移动后，可以通过鼠标距离视口的距离以及外层容器距离视口的距离的差值从而求得鼠标距离外层容器左上顶点的相对距离。

此时 鼠标移动的相对距离坐标/鼠标的可移动范围 = 图片移动的相对距离坐标/图片的可移动范围

因为图片要反向移动，可得，图片移动的相对距离坐标= -鼠标移动的相对距离坐标/鼠标的可移动范围 * 图片的可移动范围

而图片移动的相对距离，即图片绝对定位后设置的left与top值，通过修改left或者top值，即可紧随鼠标移动实现图片的反向移动的效果。

图片移动的相对位置也可以通过设置transform来实现，而且不会因为修改left和top而导致页面重排，因此更为推荐。

无论时left,top还是transform都需要设置style，可以通过计算属性返回对象来进行数据绑定。但在返回数据前，计算属性应当注意判断其依赖的值是否已经初始化，如果是与页面尺寸大小相关的值还要判断是否已经挂载能够获取。

细节处理：

获取窗口尺寸等操作保存到组件数据的操作，要在vue挂载节点之后，否则不能成功获取到元素尺寸，会发生报错。

当窗口尺寸发生变化后，需要重新获取，因此需要在vue组件挂载时注册resize事件重新获取尺寸，vue组件注销时移除resize事件。

图片的挂载时（即mounted）位置应该设置为居中，同时，为了避免鼠标突然移入而导致图片迅速移动，设置过渡属性来优化移动效果。鼠标移出时需要重新将图片位置居中。

涉及到的DOM方法以及事件

* 获取元素的宽高：Element.clientWidth/Element.clientHeight

* 获取元素距离视口的距离:Element.getBoundingClientRect()

  返回值是一个 [`DOMRect 对象`](https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect)，是包含整个元素的最小矩形（包括 `padding` 和 `border-width`）。该对象使用 `left`、`top`、`right`、`bottom`、`x`、`y`、`width` 和 `height` 这几个以像素为单位的只读属性描述整个矩形的位置和大小。除了 `width` 和 `height` 以外的属性是相对于视图窗口的左上角来计算的。

  参考文档：https://developer.mozilla.org/zh-CN/docs/Web/API/DOMRect

* 鼠标的移动事件：Element：mousemove 事件

  传入一个参数，参数中的clientX,clientY即为鼠标距离视口左上角的横纵坐标距离

  参考文档：https://developer.mozilla.org/zh-CN/docs/Web/API/Element/mousemove_event





