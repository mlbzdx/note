# 数据存储与传递

## 数据的存储

### 不同类型数据的存储方式

```js
var a = 1; //原始值类型
var b = {
 x : 1,
 y : 2
};         //引用值类型
```

数据存储时会因数据的类型不同而导致存储的方式也不同。

数据存储时会将数据分为原始值类型（数字，字符串，布尔值），还有引用值类型（数组，对象，函数等）

在存储原始值类型的数据，如上面的 `var a = 1`

会建立一片存储空间，在原存储空间下新建一个堆栈，然后将原始的数据值赋值给变量：

| a    | 1    |
| ---- | ---- |

而存储引用值类型时，首先开辟一个新的存储空间，在新空间里建立堆栈来存放引用值对象。

| x    | 1    |
| ---- | ---- |
| y    | 2    |

然后在原存储空间存储变量，并将引用值对象的地址赋值给变量。

| a    | 1                |
| ---- | ---------------- |
| b    | 引用对象存储地址 |

## 数据的传递	

### 变量赋值与存储

当变量已经被赋值，并且将其赋值给新的变量时，先判断该变量的数据类型，然后依据数据类型的存储方式进行存储。

当原变量被赋值给新变量后，如果原变量为原始值，那么修改数据或发生数据运算后，新旧变量之间的数据不会产生相互的影响，因为在原存储空间中它们分别占据不同的堆栈。

当原变量被赋值给新变量后，如果原变量为引用值，那么修改数据或发生数据运算后，新旧变量之间的数据会产生相互的影响，因为在原存储空间中它们使用相同的引用地址，当引用地址中的数据被修改后，引用该地址的所有变量的值都会发生变化。

```js
var a = 1;
var b = a;
b ++;
console.log(a,b); // 1 2
var c = {
	x : 1,
	y : 2
};
var d = c;
c.x ++
d.y --
console.log(c,d) // {x:2,y:1}  {x:2,y:1}
```

在上面的例子中，变量 a 赋值给变量 b，因为变量 a 是原始值类型，所以会在原空间新建一个堆栈来存储变量b。

| a    | 1    |
| ---- | ---- |
| b    | 1    |

发生了 `b++`的数据运算后

| a    | 1    |
| ---- | ---- |
| b    | 2    |

两个变量使用不同的堆栈，数据运算后不会发生相互间的影响。

而在变量 c 赋值给变量 d 的例子中，因为变量 c 是引用值（对象），所以会新建一个空间来存储对象，再在原空间存储变量d,并将对象存储的地址赋值给变量d。

| c    | 包含x,y属性的对象所在存储地址 |
| ---- | ----------------------------- |
| d    | 包含x,y属性的对象所在存储地址 |

新空间下存储的对象：

| x    | 1    |
| ---- | ---- |
| y    | 2    |

当修改数据或发生数据运算后，如上面的 `c.x ++,d.y--` 会直接修改存储对象的值。

| x    | 2    |
| ---- | ---- |
| y    | 1    |

因为变量 c 和 变量 d 共用同一个对象的存储地址，所以数据运算后会产生相互的影响。

### 变量的交换

由于将一个变量赋值给另一个变量会引发存储堆栈中值或地址的变化，因此交换两个变量的值通常要借助第三方变量来协助完成。

```js
var a = 1;
var b = 2;
var c = '';
c = a;
a = b;
b = c;
console.log(a,b) // 2 1
```

#### 思考1：在`js`中能否通过函数将两个变量的值进行交换？

不能，因为在 `js` 中，向函数传入的两个参数都是形参，虽然将两个变量的值赋值给了形参，且形参确实在函数作用域内部发生了交换，但是形参只能在函数作用域内起作用，不能影响到函数作用域外，当函数运行结束后，形参消失，对作用域外的两个变量不能产生任何影响，也就不能交换两个变量的值了。

#### 思考2：在 `js`中能否通过传入对象，将对象中两个属性的值进行交换？

可以，当向函数传入对象和对象的两个属性时，形参的值会指向对象所存储的地址，当形参将对象中的属性修改发生交换时，对象存储地址中的值也会发生变化并进行交换。虽然运行结束后形参消失，但是对象存储地址中的值已经发生了变化，于是实现了对象中两个属性的值的交换。